<#
.SYNOPSIS
    Automates login to BeyondTrust Password Safe, retrieves the managed account ID, requests an RDP session, and checks in the request.

.DESCRIPTION
    This script signs into BeyondTrust Password Safe, retrieves the managed account ID for a specified domain account using pagination, requests an RDP session for a specified server, creates the session, and checks in the request.
    Errors during sign-in are normal and can be ignored. The password prompt can be skipped by clicking "Cancel".

.VERSION HISTORY
    1.0 - 04-12-2024 - Initial version by Irtaza Chohan

.NOTES
    Author: Irtaza Chohan
    Date: 04-12-2024
#>

# Prompt user for the API Key and run-as user
$apiKey = Read-Host "Enter your API Key"
$runAsUser = Read-Host "Enter the run-as user (e.g., lseg\ichohan-a)"
$Credential = Get-Credential -Message "Enter your password (leave blank if not required):" -UserName $runAsUser

# Set the base URL for BeyondTrust
$BThost = "paa.prod.stockex.local"
$baseUrl = "https://${BThost}/BeyondTrust/api/public/v3/"
[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12

# Forming the Authorization header
$headers = if ($Credential.Password.Length -gt 0) {
    @{ Authorization = "PS-Auth key=${apiKey};runas=${runAsUser};pwd=[${Credential.GetNetworkCredential().Password}]" }
} else {
    @{ Authorization = "PS-Auth key=${apiKey};runas=${runAsUser}" }
}

# Sign In Block
try {
    Write-Host "Signing-in.."
    $signinResult = Invoke-RestMethod -Uri "${baseUrl}Auth/SignAppIn" -Method Post -Headers $headers -SessionVariable session
    Write-Host "..Signed-In as $($signinResult.UserName)"
} catch {
    Write-Host "Sign-in failed: $($_.Exception.Message)"
    if ($_.Exception.Response.StatusCode.value__ -eq 401 -and ($_.Exception.Response.Headers.Contains("WWW-Authenticate-2FA") -eq $true)) {
        $mfacode = Read-Host "Enter your MFA Challenge Code:"
        $headers.Authorization += ";challenge=${mfacode}"
        if ($Credential.Password.Length -gt 0) { $headers.Authorization += ";pwd=[${Credential.GetNetworkCredential().Password}]" }
        try {
            $mfaSignin = Invoke-RestMethod -Uri "${baseUrl}Auth/SignAppIn" -Method Post -ContentType "application/json" -Headers $headers -WebSession $session
            Write-Host "..Signed-In to BeyondTrust as $($mfaSignin.UserName)"
        } catch { Write-Host "MFA Sign-in failed: $($_.Exception.Message)"; throw }
    } else { throw }
}

# Define the domain and account details
$domainName = "lseg.stockex.local"
$accountName = "ichohan-a"
$serverName = "vx-2841533925"
$accessType = "RDP"

# Function to retrieve managed account ID with pagination
function Get-ManagedAccountId {
    param (
        [string]$domainName,
        [string]$accountName,
        [string]$baseUrl,
        [hashtable]$headers,
        [int]$limit = 1000
    )

    $offset = 0
    $managedAccountId = $null

    while ($true) {
        $uri = "${baseUrl}ManagedAccounts?accountname=${domainName}\${accountName}&limit=${limit}&offset=${offset}"
        Write-Host "Requesting: $uri"
        $response = Invoke-RestMethod -Uri $uri -Method Get -Headers $headers -WebSession $session
        Write-Host "Received $($response.Count) results"

        foreach ($account in $response) {
            Write-Host "Checking account: $($account.accountName)"
            if ($account.accountName -eq "${domainName}\${accountName}") {
                $managedAccountId = $account.id
                break
            }
        }

        if ($managedAccountId -ne $null -or $response.Count -lt $limit) {
            break
        }

        $offset += $limit
    }

    return $managedAccountId
}

# Retrieve the Managed Account ID
try {
    $managedAccountId = Get-ManagedAccountId -domainName $domainName -accountName $accountName -baseUrl $baseUrl -headers $headers
    if ($managedAccountId -eq $null) {
        throw "Managed account ID not found."
    }
    Write-Host "Managed Account ID: $managedAccountId"
} catch {
    Write-Host "Failed to retrieve managed account ID: $($_.Exception.Message)"
    throw
}

# Request an RDP session
$requestBody = @{
    systemName = $serverName
    accessType = $accessType
    reason = "Automated RDP session request"
}
try {
    $requestResponse = Invoke-RestMethod -Uri "${baseUrl}Requests" -Method Post -Body ($requestBody | ConvertTo-Json) -ContentType "application/json" -Headers $headers -WebSession $session
    $requestId = $requestResponse.id
    Write-Host "Request ID: $requestId"
} catch {
    Write-Host "Failed to request session: $($_.Exception.Message)"
    throw
}

# Create the session
try {
    $sessionResponse = Invoke-RestMethod -Uri "${baseUrl}Requests/$requestId/Sessions" -Method Post -Body ($requestBody | ConvertTo-Json) -ContentType "application/json" -Headers $headers -WebSession $session
    Write-Host "Session created successfully."
    # Output the session details
    $sessionResponse
} catch {
    Write-Host "Failed to create session: $($_.Exception.Message)"
    throw
}

# Check in the request
try {
    Invoke-RestMethod -Uri "${baseUrl}Requests/$requestId/Checkin" -Method Put -Headers $headers -WebSession $session
    Write-Host "Request checked in successfully."
} catch {
    Write-Host "Failed to check in request: $($_.Exception.Message)"
    throw
}

# Sign out
try {
    Invoke-RestMethod -Uri "${baseUrl}Auth/Signout" -Method Post -Headers $headers -WebSession $session
    Write-Host "Signed out successfully."
} catch {
    Write-Host "Failed to sign out: $($_.Exception.Message)"
    throw
}
